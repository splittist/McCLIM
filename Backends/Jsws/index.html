<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jsws</title>
    <style>
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script>

function JswsException(message) {
  this.message = message
  this.name = 'JswsException'
}        

const windows = {}

function setGraphicsOptions(ctx, options) {
    ctx.strokeStyle = options.stroke
    ctx.fillStyle = options.fill
    ctx.lineWidth = options.strokeLineWidth
    ctx.lineJoin = options.strokeLineJoin
    ctx.lineCap = options.strokeLineCap
    ctx.setLineDash(options.strokeDashArray ?? [])
}

// function drawLine(args) {
//     let w = windows[args[0]]
//     let line = new fabric.Line(args[1][0],args[1][1])
//     w.add(line)
// }

function drawLine(args) {
    const w = windows[args[0]]
    if (w.nodeName !== 'CANVAS') {
        throw new JswsException('Attempt to drawLine to non-canvas window')
    }
    const points = args[1][0]
    const options = args[1][1]
    const ctx = w.getContext('2d')
    ctx.save()
    setGraphicsOptions(ctx, options)
    ctx.beginPath()
    ctx.moveTo(points[0], points[1])
    ctx.lineTo(points[2], points[3])
    ctx.stroke()
    ctx.restore()
    }

// function drawRect(args) {
//     let w = windows[args[0]]
//     let rect = new fabric.Rect(args[1])
//     w.add(rect)
// }

function drawRect(args) {
    const w = windows[args[0]]
    if (w.nodeName !== 'CANVAS') {
        throw new JswsException('Attempt to drawRect to non-canvas window')
    }
    const options = args[1]
    const x = options.left
    const y = options.top
    const width = options.width
    const height = options.height
    const ctx = w.getContext('2d')
    ctx.save()
    setGraphicsOptions(ctx, options)
    ctx.beginPath()
    if (options.fill) {
        ctx.fillRect(x, y, width, height)
    } else {
        ctx.strokeRect(x, y, width, height)
    }
    ctx.restore()
}

// function drawCircle(args) {
//     let w = windows[args[0]]
//     let circle = new fabric.Circle(args[1])
//     w.add(circle)
// }

function drawCircle(args) {
    const w = windows[args[0]]
    if (w.nodeName !== 'CANVAS') {
        throw new JswsException('Attempt to drawCircle to non-canvas window')
    }
    const options = args[1]
    const x = options.x
    const y = options.y
    const radius = options.radius
    const startAngle = options.startAngle
    const endAngle = options.endAngle
    const ctx = w.getContext('2d')
    ctx.save()
    setGraphicsOptions(ctx, options)
    ctx.beginPath()
    if (startAngle) {
        ctx.moveTo(x, y)
        ctx.arc(x, y, radius, endAngle, startAngle, true)
        ctx.lineTo(x, y)
    } else {
        ctx.arc(x, y, radius, 0, 2 * Math.PI)
    }
    if (options.fill) {
        ctx.fill()
    } else {
        ctx.stroke()
    }
    ctx.restore()
}

// function drawEllipse(args) {
//     let w = windows[args[0]]
//     let ellipse = new fabric.Ellipse(args[1])
//     w.add(ellipse)
// }

function drawEllipse(args) {
    const w = windows[args[0]]
    if (w.nodeName !== 'CANVAS') {
        throw new JswsException('Attempt to drawEllipse to non-canvas window')
    }
    const options = args[1]
    const x = options.x
    const y = options.y
    const radiusX = options.rx
    const radiusY = options.ry
    const rotation = options.rotation ?? 0
    const startAngle = options.startAngle
    const endAngle = options.endAngle
    const ctx = w.getContext('2d')
    ctx.save()
    setGraphicsOptions(ctx, options)
    ctx.beginPath()
    if (startAngle) {
        ctx.moveTo(x, y)
        ctx.ellipse(x, y, radiusX, radiusY, rotation, endAngle, startAngle, true)
        ctx.lineTo(x, y)
    } else {
        ctx.ellipse(x, y, radiusX, radiusY, rotation, 0, Math.PI * 2)
    }
    if (options.fill) {
        ctx.fill()
    } else {
        ctx.stroke()
    }
    ctx.restore()
}

// function drawPolygon(args) {
//     let w = windows[args[0]]
//     let polygon = new fabric.Polygon(args[1], args[2])
//     w.add(polygon)
// }

function drawPolyline(args) {
    const w = windows[args[0]]
    if (w.nodeName !== 'CANVAS') {
        throw new JswsException('Attempt to drawPolyline to non-canvas window')
    }
    const points = args[1]
    const options = args[2]
    const start = points[0]
    const rest = points.slice(1)
    const ctx = w.getContext('2d')
    ctx.save()
    setGraphicsOptions(ctx, options)
    ctx.beginPath()
    ctx.moveTo(start.x, start.y)
    rest.forEach((point) => {
        ctx.lineTo(point.x, point.y)
    })
    if (options.fill) {
        ctx.fill()
    } else {
        ctx.stroke()
    }
    ctx.restore()
}

// function drawPolyline(args) {
//     let w = windows[args[0]]
//     let polyline = new fabric.Polyline(args[1], args[2])
//     w.add(polyline)
// }

function drawPolygon(args) {
    const w = windows[args[0]]
    if (w.nodeName !== 'CANVAS') {
        throw new JswsException('Attempt to drawPolygon to non-canvas window')
    }
    const points = args[1][0]
    const options = args[1][1]
    const start = points[0]
    const rest = points.slice(1)
    const ctx = w.getContext('2d')
    ctx.save()
    setGraphicsOptions(ctx, options)
    ctx.beginPath()
    ctx.moveTo(start.x, start.y)
    rest.forEach((point) => {
        ctx.lineTo(point.x, point.y)
    })
    ctx.fill()
    ctx.restore()
}

// function drawText(args) {
//     let w = windows[args[0]]
//     let text = new fabric.Text(args[1][0], args[1][1])
//     w.add(text)
// }

function setTextOptions(ctx, options) {
    ctx.font = `${options.fontStyle ?? 'normal'} ${options.fontWeight ?? 'normal'} ${options.fontSize ?? 10}px ${options.fontFamily ?? 'sans-serif'}`
    ctx.fillStyle = options.fill
    ctx.textBaseline = options.baseline
    ctx.direction = options.direction
}

function drawText(args) {
    const w = windows[args[0]]
    if (w.nodeName !== 'CANVAS') {
        throw new JswsException('Attempt to drawPolygon to non-canvas window')
    }
    const string = args[1][0]
    const options = args[1][1]
    const x = options.x
    const y = options.y
    const ctx = w.getContext('2d')
    ctx.save()
    setTextOptions(ctx, options)
    ctx.beginPath()
    ctx.fillText(string, x, y)
    ctx.restore()
}

const defaultWindowProperties = {
    position: 'absolute',
    top: '0',
    left: '0',
    width: `${window.innerWidth}px`,
    height: `${window.innerHeight}px`,
    zIndex: 'auto',
}

function createWindow(args) {
    const type = args[1], id = args[0]
    const el = document.createElement(type)
    el.id = id
    if (type == 'canvas') {
        el.width = window.innerWidth
        el.height = window.innerHeight
    } else {
        const options = {...defaultWindowProperties, ...args[2]}
        Object.entries(options).forEach(([key, value]) => {
            el.style[key] = value
        })
    }
    document.body.appendChild(el)
    windows[id] = el              
}

function destroyWindow(args) {
    let w = windows[args]
    let el = document.getElementById(args)
    // if (w instanceof fabric.Canvas) {
    //     w.dispose()
    // }
    el.remove()
    delete windows[args]
}

function clearWindow(id) {
    const w = windows[args]
    if (w.nodeName !== 'CANVAS') {
        throw new JswsException('Attempt to clearWindow a non-canvas window')
    }
    const ctx = w.getContext('2d')
    ctx.clearRect(0,0,w.width, w.height)
}

function textSize(args) {
    const id = args[0]
    const string = args[1]
    const options = args[2]
    const tag = args[3]
    const ctx = windows[id].getContext('2d')
    ctx.font = `${options.fontStyle} ${options.fontWeight} ${options.fontSize}px ${options.fontFamily}`
    let width, height
    if (/^\s*$/.test(string)) {
        const metricsLong = ctx.measureText(string + '|')
        const metricsShort = ctx.measureText('|')
        const metricsHeight = ctx.measureText(string)
        height = Math.abs(metricsHeight.actualBoundingBoxAscent) + Math.abs(metricsHeight.actualBoundingBoxDescent)
        width = (Math.abs(metricsLong.actualBoundingBoxLeft) + Math.abs(metricsLong.actualBoundingBoxRight))
                - (Math.abs(metricsShort.actualBoundingBoxLeft) + Math.abs(metricsShort.actualBoundingBoxRight))
    } else {
        metrics = ctx.measureText(string)
        width = Math.abs(metrics.actualBoundingBoxLeft) + Math.abs(metrics.actualBoundingBoxRight)
        height = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent)
    }
    ws.send(`(:text-size ${tag} ${width} ${height})`)
}

function screenSize(args) {
    ws.send(`(:screen-size ${args} :width ${window.innerWidth} :height ${window.innerHeight})`)
}

const ws = new WebSocket('ws://127.0.0.1:4242/port')

ws.onmessage = (event) => {
    const fns = {
        drawLine: drawLine,
        drawRect: drawRect,
        drawCircle: drawCircle,
        drawEllipse: drawEllipse,
        drawPolygon: drawPolygon,
        drawPolyline: drawPolyline,
        drawText: drawText,
        textSize: textSize,
        createWindow: createWindow,
        destroyWindow: destroyWindow,
        screenSize: screenSize,
    }
    let messages = JSON.parse(event.data)
    messages.forEach(([fName, ...args]) => fns[fName](...args))
}

ws.onopen = () => {
    console.log('Connected')
}

ws.onclose = () => {
    console.log('Disconnected')
}

function makeModifierState(e) {
    let result = 0
    if (e.shiftKey)                   { result |= 0x0100 }
    if (e.ctrlKey)                    { result |= 0x0200 }
    if (e.metaKey)                    { result |= 0x0400 }
    if (e.getModifierState('Super'))  { result |= 0x0800 }
    if (e.getModifierState('Hyper'))  { result |= 0x1000 }
    if (e.altKey)                     { result |= 0x2000 }
    return result
}

function makeButtonState(e) {
    let result = 0
    const buttons = e.buttons
    if ( buttons & 1 ) { result |= 1 }
    if ( buttons & 2 ) { result |= 4 }
    if ( buttons & 4 ) { result |= 2 }
    return result
}

const pointerPosition = { x: 0, y: 0 }

const windowListeners = {
    'keydown': handleKeydown,
    'keyup': handleKeyup,
    'pointerdown': handlePointerdown,
    'pointerup': handlePointerup,
    'pointerenter': handlePointerenter,
    'pointerleave': handlePointerleave,
    'pointermove': handlePointermove,
}

function addWindowListeners() {
    Object.entries(windowListeners).forEach(([type, callback]) => {
        addGlobalEventListener(type, callback)
    })
}

function addGlobalEventListener(type, callback) {
    document.addEventListener(type, e => {
        callback(e)
    })
}

function handleKeydown(e) {
    ws.send(`(:event :key-press-event :char "${e.key}" :mod ${makeModifierState(e)} :loc ${e.location} :x ${pointerPosition.x} :y ${pointerPosition.y})`)
}

function handleKeyup(e) {
    ws.send(`(:event :key-release-event :char "${e.key}" :mod ${makeModifierState(e)} :loc ${e.location} :x ${pointerPosition.x} :y ${pointerPosition.y})`)
}

function handlePointerdown(e) {
    ws.send(`(:event :pointer-button-press-event :but ${makeButtonState(e)} :x ${e.clientX} :y ${e.clientY} :mod ${makeModifierState(e)})`)
}

function handlePointerup(e) {
    ws.send(`(:event :pointer-button-release-event :but ${makeButtonState(e)} :x ${e.clientX} :y ${e.clientY} :mod ${makeModifierState(e)})`)
}

function handlePointerenter(e) {
    ws.send(`(:event :pointer-enter-event :but ${makeButtonState(e)} :x ${e.clientX} :y ${e.clientY} :mod ${makeModifierState(e)})`)
}

function handlePointerleave(e) {
    ws.send(`(:event :pointer-exit-event :but ${makeButtonState(e)} :x ${e.clientX} :y ${e.clientY} :mod ${makeModifierState(e)})`)
}

function handlePointermove(e) {
    pointerPosition.x = e.clientX
    pointerPosition.y = e.clientY
    ws.send(`(:event :pointer-motion-event :but ${makeButtonState(e)} :x ${e.clientX} :y ${e.clientY} :mod ${makeModifierState(e)})`)
}

    </script>
</body>
</html>